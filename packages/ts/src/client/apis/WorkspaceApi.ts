/* tslint:disable */
/* eslint-disable */
/**
 * Daytona Server API
 * Daytona Server API
 *
 * The version of the OpenAPI document: v0.0.0-dev
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CreateWorkspaceDTO,
  ExecuteRequest,
  ExecuteResponse,
  FileInfo,
  LspCompletionParams,
  LspDocumentRequest,
  LspServerRequest,
  Match,
  ReplaceRequest,
  SetProjectState,
  Workspace,
  WorkspaceDTO,
} from '../models/index';
import {
    CreateWorkspaceDTOFromJSON,
    CreateWorkspaceDTOToJSON,
    ExecuteRequestFromJSON,
    ExecuteRequestToJSON,
    ExecuteResponseFromJSON,
    ExecuteResponseToJSON,
    FileInfoFromJSON,
    FileInfoToJSON,
    LspCompletionParamsFromJSON,
    LspCompletionParamsToJSON,
    LspDocumentRequestFromJSON,
    LspDocumentRequestToJSON,
    LspServerRequestFromJSON,
    LspServerRequestToJSON,
    MatchFromJSON,
    MatchToJSON,
    ReplaceRequestFromJSON,
    ReplaceRequestToJSON,
    SetProjectStateFromJSON,
    SetProjectStateToJSON,
    WorkspaceFromJSON,
    WorkspaceToJSON,
    WorkspaceDTOFromJSON,
    WorkspaceDTOToJSON,
} from '../models/index';

export interface CreateWorkspaceRequest {
    workspace: CreateWorkspaceDTO;
}

export interface DeleteFileRequest {
    workspaceId: string;
    projectId: string;
    path: string;
}

export interface DownloadFileRequest {
    workspaceId: string;
    projectId: string;
    path: string;
}

export interface ExecuteCommandRequest {
    workspaceId: string;
    projectId: string;
    params: ExecuteRequest;
}

export interface FindInFilesRequest {
    workspaceId: string;
    projectId: string;
    path: string;
    pattern: string;
}

export interface GetFileDetailsRequest {
    workspaceId: string;
    projectId: string;
    path: string;
}

export interface GetWorkspaceRequest {
    workspaceId: string;
    verbose?: boolean;
}

export interface ListFilesRequest {
    workspaceId: string;
    projectId: string;
    path?: string;
}

export interface ListWorkspacesRequest {
    verbose?: boolean;
}

export interface LspCompletionsRequest {
    workspaceId: string;
    projectId: string;
    params: LspCompletionParams;
}

export interface LspDidCloseRequest {
    workspaceId: string;
    projectId: string;
    server: LspDocumentRequest;
}

export interface LspDidOpenRequest {
    workspaceId: string;
    projectId: string;
    server: LspDocumentRequest;
}

export interface LspDocumentSymbolsRequest {
    workspaceId: string;
    projectId: string;
    languageId: string;
    uri: string;
}

export interface LspStartRequest {
    workspaceId: string;
    projectId: string;
    server: LspServerRequest;
}

export interface LspStopRequest {
    workspaceId: string;
    projectId: string;
    server: LspServerRequest;
}

export interface LspWorkspaceSymbolsRequest {
    workspaceId: string;
    projectId: string;
    languageId: string;
    query: string;
}

export interface RemoveWorkspaceRequest {
    workspaceId: string;
    force?: boolean;
}

export interface ReplaceInFilesRequest {
    workspaceId: string;
    projectId: string;
    replace: ReplaceRequest;
}

export interface SearchFilesRequest {
    workspaceId: string;
    projectId: string;
    path: string;
    pattern: string;
}

export interface SetFilePermissionsRequest {
    workspaceId: string;
    projectId: string;
    path: string;
    owner?: string;
    group?: string;
    mode?: string;
}

export interface SetProjectStateRequest {
    workspaceId: string;
    projectId: string;
    setState: SetProjectState;
}

export interface StartProjectRequest {
    workspaceId: string;
    projectId: string;
}

export interface StartWorkspaceRequest {
    workspaceId: string;
}

export interface StopProjectRequest {
    workspaceId: string;
    projectId: string;
}

export interface StopWorkspaceRequest {
    workspaceId: string;
}

export interface UploadFileRequest {
    workspaceId: string;
    projectId: string;
    path: string;
    file: Blob;
}

/**
 * 
 */
export class WorkspaceApi extends runtime.BaseAPI {

    /**
     * Create a workspace
     * Create a workspace
     */
    async createWorkspaceRaw(requestParameters: CreateWorkspaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Workspace>> {
        if (requestParameters['workspace'] == null) {
            throw new runtime.RequiredError(
                'workspace',
                'Required parameter "workspace" was null or undefined when calling createWorkspace().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/workspace`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateWorkspaceDTOToJSON(requestParameters['workspace']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceFromJSON(jsonValue));
    }

    /**
     * Create a workspace
     * Create a workspace
     */
    async createWorkspace(requestParameters: CreateWorkspaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Workspace> {
        const response = await this.createWorkspaceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete file inside workspace project
     * Delete file
     */
    async deleteFileRaw(requestParameters: DeleteFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling deleteFile().'
            );
        }

        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling deleteFile().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling deleteFile().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/workspace/{workspaceId}/{projectId}/toolbox/files`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(requestParameters['workspaceId']))).replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete file inside workspace project
     * Delete file
     */
    async deleteFile(requestParameters: DeleteFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteFileRaw(requestParameters, initOverrides);
    }

    /**
     * Download file from workspace project
     * Download file
     */
    async downloadFileRaw(requestParameters: DownloadFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling downloadFile().'
            );
        }

        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling downloadFile().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling downloadFile().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/workspace/{workspaceId}/{projectId}/toolbox/files/download`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(requestParameters['workspaceId']))).replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Download file from workspace project
     * Download file
     */
    async downloadFile(requestParameters: DownloadFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.downloadFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Execute command synchronously inside workspace project
     * Execute command
     */
    async executeCommandRaw(requestParameters: ExecuteCommandRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExecuteResponse>> {
        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling executeCommand().'
            );
        }

        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling executeCommand().'
            );
        }

        if (requestParameters['params'] == null) {
            throw new runtime.RequiredError(
                'params',
                'Required parameter "params" was null or undefined when calling executeCommand().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/workspace/{workspaceId}/{projectId}/toolbox/process/execute`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(requestParameters['workspaceId']))).replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ExecuteRequestToJSON(requestParameters['params']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExecuteResponseFromJSON(jsonValue));
    }

    /**
     * Execute command synchronously inside workspace project
     * Execute command
     */
    async executeCommand(requestParameters: ExecuteCommandRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExecuteResponse> {
        const response = await this.executeCommandRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search for text/pattern inside workspace project files
     * Search for text/pattern in files
     */
    async findInFilesRaw(requestParameters: FindInFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Match>>> {
        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling findInFiles().'
            );
        }

        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling findInFiles().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling findInFiles().'
            );
        }

        if (requestParameters['pattern'] == null) {
            throw new runtime.RequiredError(
                'pattern',
                'Required parameter "pattern" was null or undefined when calling findInFiles().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        if (requestParameters['pattern'] != null) {
            queryParameters['pattern'] = requestParameters['pattern'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/workspace/{workspaceId}/{projectId}/toolbox/files/find`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(requestParameters['workspaceId']))).replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MatchFromJSON));
    }

    /**
     * Search for text/pattern inside workspace project files
     * Search for text/pattern in files
     */
    async findInFiles(requestParameters: FindInFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Match>> {
        const response = await this.findInFilesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get file info inside workspace project
     * Get file info
     */
    async getFileDetailsRaw(requestParameters: GetFileDetailsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FileInfo>> {
        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling getFileDetails().'
            );
        }

        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling getFileDetails().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling getFileDetails().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/workspace/{workspaceId}/{projectId}/toolbox/files/info`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(requestParameters['workspaceId']))).replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FileInfoFromJSON(jsonValue));
    }

    /**
     * Get file info inside workspace project
     * Get file info
     */
    async getFileDetails(requestParameters: GetFileDetailsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FileInfo> {
        const response = await this.getFileDetailsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get workspace info
     * Get workspace info
     */
    async getWorkspaceRaw(requestParameters: GetWorkspaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WorkspaceDTO>> {
        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling getWorkspace().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['verbose'] != null) {
            queryParameters['verbose'] = requestParameters['verbose'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/workspace/{workspaceId}`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(requestParameters['workspaceId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceDTOFromJSON(jsonValue));
    }

    /**
     * Get workspace info
     * Get workspace info
     */
    async getWorkspace(requestParameters: GetWorkspaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WorkspaceDTO> {
        const response = await this.getWorkspaceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List files inside workspace project
     * List files
     */
    async listFilesRaw(requestParameters: ListFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<FileInfo>>> {
        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling listFiles().'
            );
        }

        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling listFiles().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/workspace/{workspaceId}/{projectId}/toolbox/files`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(requestParameters['workspaceId']))).replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(FileInfoFromJSON));
    }

    /**
     * List files inside workspace project
     * List files
     */
    async listFiles(requestParameters: ListFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<FileInfo>> {
        const response = await this.listFilesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List workspaces
     * List workspaces
     */
    async listWorkspacesRaw(requestParameters: ListWorkspacesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<WorkspaceDTO>>> {
        const queryParameters: any = {};

        if (requestParameters['verbose'] != null) {
            queryParameters['verbose'] = requestParameters['verbose'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/workspace`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(WorkspaceDTOFromJSON));
    }

    /**
     * List workspaces
     * List workspaces
     */
    async listWorkspaces(requestParameters: ListWorkspacesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<WorkspaceDTO>> {
        const response = await this.listWorkspacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * The Completion request is sent from the client to the server to compute completion items at a given cursor position.
     * Get Lsp Completions
     */
    async lspCompletionsRaw(requestParameters: LspCompletionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Match>>> {
        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling lspCompletions().'
            );
        }

        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling lspCompletions().'
            );
        }

        if (requestParameters['params'] == null) {
            throw new runtime.RequiredError(
                'params',
                'Required parameter "params" was null or undefined when calling lspCompletions().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/workspace/{workspaceId}/{projectId}/toolbox/lsp/completions`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(requestParameters['workspaceId']))).replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LspCompletionParamsToJSON(requestParameters['params']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MatchFromJSON));
    }

    /**
     * The Completion request is sent from the client to the server to compute completion items at a given cursor position.
     * Get Lsp Completions
     */
    async lspCompletions(requestParameters: LspCompletionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Match>> {
        const response = await this.lspCompletionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * The document close notification is sent from the client to the server when the document got closed in the client.
     * Call Lsp DidClose
     */
    async lspDidCloseRaw(requestParameters: LspDidCloseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Match>>> {
        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling lspDidClose().'
            );
        }

        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling lspDidClose().'
            );
        }

        if (requestParameters['server'] == null) {
            throw new runtime.RequiredError(
                'server',
                'Required parameter "server" was null or undefined when calling lspDidClose().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/workspace/{workspaceId}/{projectId}/toolbox/lsp/didclose`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(requestParameters['workspaceId']))).replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LspDocumentRequestToJSON(requestParameters['server']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MatchFromJSON));
    }

    /**
     * The document close notification is sent from the client to the server when the document got closed in the client.
     * Call Lsp DidClose
     */
    async lspDidClose(requestParameters: LspDidCloseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Match>> {
        const response = await this.lspDidCloseRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * The document open notification is sent from the client to the server to signal newly opened text documents.
     * Call Lsp DidOpen
     */
    async lspDidOpenRaw(requestParameters: LspDidOpenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Match>>> {
        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling lspDidOpen().'
            );
        }

        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling lspDidOpen().'
            );
        }

        if (requestParameters['server'] == null) {
            throw new runtime.RequiredError(
                'server',
                'Required parameter "server" was null or undefined when calling lspDidOpen().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/workspace/{workspaceId}/{projectId}/toolbox/lsp/didopen`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(requestParameters['workspaceId']))).replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LspDocumentRequestToJSON(requestParameters['server']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MatchFromJSON));
    }

    /**
     * The document open notification is sent from the client to the server to signal newly opened text documents.
     * Call Lsp DidOpen
     */
    async lspDidOpen(requestParameters: LspDidOpenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Match>> {
        const response = await this.lspDidOpenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * The document symbol request is sent from the client to the server.
     * Call Lsp DocumentSymbols
     */
    async lspDocumentSymbolsRaw(requestParameters: LspDocumentSymbolsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Match>>> {
        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling lspDocumentSymbols().'
            );
        }

        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling lspDocumentSymbols().'
            );
        }

        if (requestParameters['languageId'] == null) {
            throw new runtime.RequiredError(
                'languageId',
                'Required parameter "languageId" was null or undefined when calling lspDocumentSymbols().'
            );
        }

        if (requestParameters['uri'] == null) {
            throw new runtime.RequiredError(
                'uri',
                'Required parameter "uri" was null or undefined when calling lspDocumentSymbols().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['languageId'] != null) {
            queryParameters['languageId'] = requestParameters['languageId'];
        }

        if (requestParameters['uri'] != null) {
            queryParameters['uri'] = requestParameters['uri'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/workspace/{workspaceId}/{projectId}/toolbox/lsp/documentSymbols`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(requestParameters['workspaceId']))).replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MatchFromJSON));
    }

    /**
     * The document symbol request is sent from the client to the server.
     * Call Lsp DocumentSymbols
     */
    async lspDocumentSymbols(requestParameters: LspDocumentSymbolsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Match>> {
        const response = await this.lspDocumentSymbolsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Start Lsp server process inside workspace project
     * Start Lsp server
     */
    async lspStartRaw(requestParameters: LspStartRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Match>>> {
        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling lspStart().'
            );
        }

        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling lspStart().'
            );
        }

        if (requestParameters['server'] == null) {
            throw new runtime.RequiredError(
                'server',
                'Required parameter "server" was null or undefined when calling lspStart().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/workspace/{workspaceId}/{projectId}/toolbox/lsp/start`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(requestParameters['workspaceId']))).replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LspServerRequestToJSON(requestParameters['server']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MatchFromJSON));
    }

    /**
     * Start Lsp server process inside workspace project
     * Start Lsp server
     */
    async lspStart(requestParameters: LspStartRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Match>> {
        const response = await this.lspStartRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Stop Lsp server process inside workspace project
     * Stop Lsp server
     */
    async lspStopRaw(requestParameters: LspStopRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Match>>> {
        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling lspStop().'
            );
        }

        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling lspStop().'
            );
        }

        if (requestParameters['server'] == null) {
            throw new runtime.RequiredError(
                'server',
                'Required parameter "server" was null or undefined when calling lspStop().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/workspace/{workspaceId}/{projectId}/toolbox/lsp/stop`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(requestParameters['workspaceId']))).replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LspServerRequestToJSON(requestParameters['server']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MatchFromJSON));
    }

    /**
     * Stop Lsp server process inside workspace project
     * Stop Lsp server
     */
    async lspStop(requestParameters: LspStopRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Match>> {
        const response = await this.lspStopRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * The workspace symbol request is sent from the client to the server to list project-wide symbols matching the query string.
     * Call Lsp WorkspaceSymbols
     */
    async lspWorkspaceSymbolsRaw(requestParameters: LspWorkspaceSymbolsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Match>>> {
        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling lspWorkspaceSymbols().'
            );
        }

        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling lspWorkspaceSymbols().'
            );
        }

        if (requestParameters['languageId'] == null) {
            throw new runtime.RequiredError(
                'languageId',
                'Required parameter "languageId" was null or undefined when calling lspWorkspaceSymbols().'
            );
        }

        if (requestParameters['query'] == null) {
            throw new runtime.RequiredError(
                'query',
                'Required parameter "query" was null or undefined when calling lspWorkspaceSymbols().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['languageId'] != null) {
            queryParameters['languageId'] = requestParameters['languageId'];
        }

        if (requestParameters['query'] != null) {
            queryParameters['query'] = requestParameters['query'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/workspace/{workspaceId}/{projectId}/toolbox/lsp/workspaceSymbols`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(requestParameters['workspaceId']))).replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MatchFromJSON));
    }

    /**
     * The workspace symbol request is sent from the client to the server to list project-wide symbols matching the query string.
     * Call Lsp WorkspaceSymbols
     */
    async lspWorkspaceSymbols(requestParameters: LspWorkspaceSymbolsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Match>> {
        const response = await this.lspWorkspaceSymbolsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove workspace
     * Remove workspace
     */
    async removeWorkspaceRaw(requestParameters: RemoveWorkspaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling removeWorkspace().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/workspace/{workspaceId}`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(requestParameters['workspaceId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove workspace
     * Remove workspace
     */
    async removeWorkspace(requestParameters: RemoveWorkspaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.removeWorkspaceRaw(requestParameters, initOverrides);
    }

    /**
     * Repleace text/pattern in mutilple files inside workspace project
     * Repleace text/pattern in files
     */
    async replaceInFilesRaw(requestParameters: ReplaceInFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Match>>> {
        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling replaceInFiles().'
            );
        }

        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling replaceInFiles().'
            );
        }

        if (requestParameters['replace'] == null) {
            throw new runtime.RequiredError(
                'replace',
                'Required parameter "replace" was null or undefined when calling replaceInFiles().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/workspace/{workspaceId}/{projectId}/toolbox/files/replace`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(requestParameters['workspaceId']))).replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReplaceRequestToJSON(requestParameters['replace']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MatchFromJSON));
    }

    /**
     * Repleace text/pattern in mutilple files inside workspace project
     * Repleace text/pattern in files
     */
    async replaceInFiles(requestParameters: ReplaceInFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Match>> {
        const response = await this.replaceInFilesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search for files inside workspace project
     * Search for files
     */
    async searchFilesRaw(requestParameters: SearchFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<string>>> {
        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling searchFiles().'
            );
        }

        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling searchFiles().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling searchFiles().'
            );
        }

        if (requestParameters['pattern'] == null) {
            throw new runtime.RequiredError(
                'pattern',
                'Required parameter "pattern" was null or undefined when calling searchFiles().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        if (requestParameters['pattern'] != null) {
            queryParameters['pattern'] = requestParameters['pattern'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/workspace/{workspaceId}/{projectId}/toolbox/files/search`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(requestParameters['workspaceId']))).replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Search for files inside workspace project
     * Search for files
     */
    async searchFiles(requestParameters: SearchFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<string>> {
        const response = await this.searchFilesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Set file owner/group/permissions inside workspace project
     * Set file owner/group/permissions
     */
    async setFilePermissionsRaw(requestParameters: SetFilePermissionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling setFilePermissions().'
            );
        }

        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling setFilePermissions().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling setFilePermissions().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        if (requestParameters['owner'] != null) {
            queryParameters['owner'] = requestParameters['owner'];
        }

        if (requestParameters['group'] != null) {
            queryParameters['group'] = requestParameters['group'];
        }

        if (requestParameters['mode'] != null) {
            queryParameters['mode'] = requestParameters['mode'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/workspace/{workspaceId}/{projectId}/toolbox/files/permissions`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(requestParameters['workspaceId']))).replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Set file owner/group/permissions inside workspace project
     * Set file owner/group/permissions
     */
    async setFilePermissions(requestParameters: SetFilePermissionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.setFilePermissionsRaw(requestParameters, initOverrides);
    }

    /**
     * Set project state
     * Set project state
     */
    async setProjectStateRaw(requestParameters: SetProjectStateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling setProjectState().'
            );
        }

        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling setProjectState().'
            );
        }

        if (requestParameters['setState'] == null) {
            throw new runtime.RequiredError(
                'setState',
                'Required parameter "setState" was null or undefined when calling setProjectState().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/workspace/{workspaceId}/{projectId}/state`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(requestParameters['workspaceId']))).replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SetProjectStateToJSON(requestParameters['setState']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Set project state
     * Set project state
     */
    async setProjectState(requestParameters: SetProjectStateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.setProjectStateRaw(requestParameters, initOverrides);
    }

    /**
     * Start project
     * Start project
     */
    async startProjectRaw(requestParameters: StartProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling startProject().'
            );
        }

        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling startProject().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/workspace/{workspaceId}/{projectId}/start`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(requestParameters['workspaceId']))).replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Start project
     * Start project
     */
    async startProject(requestParameters: StartProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.startProjectRaw(requestParameters, initOverrides);
    }

    /**
     * Start workspace
     * Start workspace
     */
    async startWorkspaceRaw(requestParameters: StartWorkspaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling startWorkspace().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/workspace/{workspaceId}/start`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(requestParameters['workspaceId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Start workspace
     * Start workspace
     */
    async startWorkspace(requestParameters: StartWorkspaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.startWorkspaceRaw(requestParameters, initOverrides);
    }

    /**
     * Stop project
     * Stop project
     */
    async stopProjectRaw(requestParameters: StopProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling stopProject().'
            );
        }

        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling stopProject().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/workspace/{workspaceId}/{projectId}/stop`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(requestParameters['workspaceId']))).replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Stop project
     * Stop project
     */
    async stopProject(requestParameters: StopProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.stopProjectRaw(requestParameters, initOverrides);
    }

    /**
     * Stop workspace
     * Stop workspace
     */
    async stopWorkspaceRaw(requestParameters: StopWorkspaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling stopWorkspace().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/workspace/{workspaceId}/stop`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(requestParameters['workspaceId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Stop workspace
     * Stop workspace
     */
    async stopWorkspace(requestParameters: StopWorkspaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.stopWorkspaceRaw(requestParameters, initOverrides);
    }

    /**
     * Upload file inside workspace project
     * Upload file
     */
    async uploadFileRaw(requestParameters: UploadFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling uploadFile().'
            );
        }

        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling uploadFile().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling uploadFile().'
            );
        }

        if (requestParameters['file'] == null) {
            throw new runtime.RequiredError(
                'file',
                'Required parameter "file" was null or undefined when calling uploadFile().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }

        const response = await this.request({
            path: `/workspace/{workspaceId}/{projectId}/toolbox/files`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(requestParameters['workspaceId']))).replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Upload file inside workspace project
     * Upload file
     */
    async uploadFile(requestParameters: UploadFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.uploadFileRaw(requestParameters, initOverrides);
    }

}
